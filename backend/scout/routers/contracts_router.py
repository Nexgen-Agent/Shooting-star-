# scout/routers/contracts_router.py
from fastapi import APIRouter, HTTPException, BackgroundTasks, Depends
from typing import List, Optional
from pydantic import BaseModel

from ..models.contracts import InfluencerContract, LoanAgreement, RevenueShareLog, ContractStatus
from ..contracts.fair_value import FairValueCalculator
from ..onboard.onboarding_service import OnboardingService

router = APIRouter(prefix="/api/v1/scout/contracts", tags=["contracts"])
fair_value_calc = FairValueCalculator()
onboarding_service = OnboardingService()

class ContractCreateRequest(BaseModel):
    influencer_id: str
    influencer_name: str
    influencer_tier: str
    requested_loan_amount: float
    team_support_index: float = 0.5
    contract_duration_days: int = 365

class RevenuePaymentRequest(BaseModel):
    contract_id: str
    payment_amount: float
    payment_date: str
    revenue_period: str

@router.post("/create", response_model=InfluencerContract)
async def create_contract(request: ContractCreateRequest):
    """Create a new fair value partnership contract"""
    try:
        # Get influencer profile (would come from database in production)
        influencer_profile = {
            'tier': request.influencer_tier,
            'followers': 100000,  # Would be real data
            'engagement_rate': 0.045,
            'niche': 'tech'
        }
        
        # Calculate fair value terms
        fair_value_terms = fair_value_calc.calculate_fair_split(
            influencer_profile,
            request.requested_loan_amount,
            request.team_support_index
        )
        
        # Create contract
        contract = InfluencerContract(
            id=f"contract_{request.influencer_id}_{datetime.utcnow().timestamp()}",
            influencer_id=request.influencer_id,
            influencer_name=request.influencer_name,
            influencer_tier=request.influencer_tier,
            partner_type="influencer",
            contract_duration_days=request.contract_duration_days,
            loan_amount=request.requested_loan_amount,
            repayment_rate=fair_value_terms['repayment_rate'],
            growth_split=fair_value_terms['growth_split'],
            current_revenue_share=fair_value_terms['base_split_influencer'],
            projected_roi=fair_value_terms['projected_roi'],
            status=ContractStatus.PENDING_APPROVAL,
            agency_support_notes=["Automatically generated by Fair Value Calculator"]
        )
        
        # TODO: Save to database
        # await save_contract(contract)
        
        return contract
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating contract: {str(e)}")

@router.get("/{contract_id}", response_model=InfluencerContract)
async def get_contract(contract_id: str):
    """Get contract details"""
    # TODO: Fetch from database
    # For now, return a mock contract
    return InfluencerContract(
        id=contract_id,
        influencer_id="test_influencer",
        influencer_name="Test Influencer",
        influencer_tier="mid",
        partner_type="influencer",
        contract_duration_days=365,
        loan_amount=10000,
        repayment_rate=0.9,
        growth_split=0.5,
        current_revenue_share=0.7,
        projected_roi=2.5,
        status=ContractStatus.ACTIVE
    )

@router.patch("/{contract_id}/update")
async def update_contract(contract_id: str, updates: dict):
    """Update contract details"""
    try:
        # TODO: Implement contract update logic
        # This would validate updates and apply them to the contract
        
        return {"status": "updated", "contract_id": contract_id, "updates": updates}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/{contract_id}/revenue-payment")
async def record_revenue_payment(contract_id: str, payment: RevenuePaymentRequest):
    """Record a revenue payment and update contract state"""
    try:
        # TODO: Implement revenue payment logic
        # This would:
        # 1. Calculate loan repayment amount
        # 2. Calculate influencer payout
        # 3. Update repayment progress
        # 4. Adjust revenue share if loan is repaid
        
        result = {
            "contract_id": contract_id,
            "payment_processed": True,
            "loan_repayment_amount": payment.payment_amount * 0.9,
            "influencer_payout": payment.payment_amount * 0.1,
            "new_repayment_progress": 0.25  # Would be calculated
        }
        
        return result
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{contract_id}/revenue-history", response_model=List[RevenueShareLog])
async def get_revenue_history(contract_id: str):
    """Get revenue share history for a contract"""
    # TODO: Fetch from database
    return [
        RevenueShareLog(
            id="log_1",
            contract_id=contract_id,
            payment_date=datetime.utcnow(),
            amount=1000.0,
            revenue_share_percentage=0.7,
            loan_repayment_amount=900.0,
            influencer_payout=100.0,
            platform_fee=0.0
        )
    ]