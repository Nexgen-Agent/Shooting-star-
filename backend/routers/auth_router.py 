"""
Authentication router for user login, registration, and token management.
"""

from typing import Dict, Any
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
import logging

from database.connection import get_db
from services.auth_service import AuthService
from core.security import require_roles, get_current_user
from core.utils import response_formatter
from config.constants import UserRole
from database.models.user import User

# Create router
router = APIRouter(prefix="/auth", tags=["authentication"])

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")

logger = logging.getLogger(__name__)


@router.post("/login", response_model=Dict[str, Any])
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db)
):
    """
    User login endpoint.
    
    Args:
        form_data: Login form data
        db: Database session
        
    Returns:
        Access token and user data
    """
    auth_service = AuthService(db)
    
    # Authenticate user
    user = await auth_service.authenticate_user(form_data.username, form_data.password)
    if not user:
        raise response_formatter.error(
            message="Invalid email or password",
            error_code="INVALID_CREDENTIALS",
            status_code=status.HTTP_401_UNAUTHORIZED
        )
    
    # Generate access token
    token_data = await auth_service.generate_access_token(user)
    
    logger.info(f"User logged in successfully: {user.email}")
    return response_formatter.success(
        data=token_data,
        message="Login successful"
    )


@router.post("/register", response_model=Dict[str, Any])
async def register(
    user_data: dict,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(require_roles([UserRole.SUPER_ADMIN]))
):
    """
    Register new user (admin only).
    
    Args:
        user_data: User registration data
        db: Database session
        current_user: Current authenticated user
        
    Returns:
        Registration result
    """
    auth_service = AuthService(db)
    
    # Validate required fields
    required_fields = ["email", "password", "first_name", "last_name", "role"]
    for field in required_fields:
        if field not in user_data:
            raise response_formatter.error(
                message=f"Missing required field: {field}",
                error_code="MISSING_REQUIRED_FIELD",
                status_code=status.HTTP_400_BAD_REQUEST
            )
    
    # Create user
    success, user, message = await auth_service.create_user(**user_data)
    
    if not success:
        raise response_formatter.error(
            message=message,
            error_code="USER_CREATION_FAILED",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    
    logger.info(f"New user registered by {current_user.email}: {user_data['email']}")
    return response_formatter.success(
        data=user.to_dict(),
        message=message
    )


@router.post("/refresh", response_model=Dict[str, Any])
async def refresh_token(
    token_data: dict,
    db: AsyncSession = Depends(get_db)
):
    """
    Refresh access token.
    
    Args:
        token_data: Token data containing current token
        db: Database session
        
    Returns:
        New access token
    """
    auth_service = AuthService(db)
    
    token = token_data.get("token")
    if not token:
        raise response_formatter.error(
            message="Token is required",
            error_code="MISSING_TOKEN",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    
    # Refresh token
    new_token_data = await auth_service.refresh_token(token)
    if not new_token_data:
        raise response_formatter.error(
            message="Invalid or expired token",
            error_code="INVALID_TOKEN",
            status_code=status.HTTP_401_UNAUTHORIZED
        )
    
    return response_formatter.success(
        data=new_token_data,
        message="Token refreshed successfully"
    )


@router.post("/change-password", response_model=Dict[str, Any])
async def change_password(
    password_data: dict,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Change user password.
    
    Args:
        password_data: Password change data
        db: Database session
        current_user: Current authenticated user
        
    Returns:
        Password change result
    """
    auth_service = AuthService(db)
    
    current_password = password_data.get("current_password")
    new_password = password_data.get("new_password")
    
    if not current_password or not new_password:
        raise response_formatter.error(
            message="Current password and new password are required",
            error_code="MISSING_PASSWORD_FIELDS",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    
    # Change password
    success, message = await auth_service.change_password(
        str(current_user.id), current_password, new_password
    )
    
    if not success:
        raise response_formatter.error(
            message=message,
            error_code="PASSWORD_CHANGE_FAILED",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    
    logger.info(f"Password changed for user: {current_user.email}")
    return response_formatter.success(message=message)


@router.post("/reset-password", response_model=Dict[str, Any])
async def reset_password(
    reset_data: dict,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(require_roles([UserRole.SUPER_ADMIN]))
):
    """
    Reset user password (admin only).
    
    Args:
        reset_data: Password reset data
        db: Database session
        current_user: Current authenticated admin
        
    Returns:
        Password reset result
    """
    auth_service = AuthService(db)
    
    email = reset_data.get("email")
    new_password = reset_data.get("new_password")
    
    if not email or not new_password:
        raise response_formatter.error(
            message="Email and new password are required",
            error_code="MISSING_RESET_FIELDS",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    
    # Reset password
    success, message = await auth_service.reset_password(email, new_password)
    
    if not success:
        raise response_formatter.error(
            message=message,
            error_code="PASSWORD_RESET_FAILED",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    
    logger.info(f"Password reset by admin {current_user.email} for user: {email}")
    return response_formatter.success(message=message)


@router.get("/me", response_model=Dict[str, Any])
async def get_current_user_profile(
    current_user: User = Depends(get_current_user)
):
    """
    Get current user profile.
    
    Args:
        current_user: Current authenticated user
        
    Returns:
        User profile data
    """
    return response_formatter.success(
        data=current_user.to_dict(),
        message="Profile retrieved successfully"
    )


@router.put("/me", response_model=Dict[str, Any])
async def update_current_user_profile(
    update_data: dict,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Update current user profile.
    
    Args:
        update_data: Profile update data
        db: Database session
        current_user: Current authenticated user
        
    Returns:
        Updated profile data
    """
    auth_service = AuthService(db)
    
    success, user, message = await auth_service.update_user_profile(
        str(current_user.id), update_data
    )
    
    if not success:
        raise response_formatter.error(
            message=message,
            error_code="PROFILE_UPDATE_FAILED",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    
    return response_formatter.success(
        data=user.to_dict(),
        message=message
    )


@router.post("/logout", response_model=Dict[str, Any])
async def logout():
    """
    User logout endpoint.
    
    Note: Since JWT is stateless, logout is handled client-side by removing the token.
    
    Returns:
        Logout confirmation
    """
    return response_formatter.success(
        message="Logout successful. Please remove the token client-side."
    )


@router.get("/users", response_model=Dict[str, Any])
async def list_users(
    brand_id: str = None,
    role: UserRole = None,
    page: int = 1,
    per_page: int = 20,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(require_roles([UserRole.SUPER_ADMIN, UserRole.BRAND_OWNER]))
):
    """
    List users with filtering and pagination.
    
    Args:
        brand_id: Filter by brand ID
        role: Filter by role
        page: Page number
        per_page: Items per page
        db: Database session
        current_user: Current authenticated user
        
    Returns:
        Paginated list of users
    """
    auth_service = AuthService(db)
    
    # If user is brand owner, only show users from their brand
    if current_user.role == UserRole.BRAND_OWNER:
        brand_id = str(current_user.brand_id)
    
    users, total_count = await auth_service.list_users(
        brand_id=brand_id,
        role=role,
        page=page,
        per_page=per_page
    )
    
    from core.utils import Paginator
    paginator = Paginator(page, per_page)
    meta = paginator.create_metadata(total_count)
    
    return response_formatter.success(
        data=[user.to_dict() for user in users],
        meta=meta,
        message="Users retrieved successfully"
    )


@router.delete("/users/{user_id}", response_model=Dict[str, Any])
async def deactivate_user(
    user_id: str,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(require_roles([UserRole.SUPER_ADMIN, UserRole.BRAND_OWNER]))
):
    """
    Deactivate user account.
    
    Args:
        user_id: User ID to deactivate
        db: Database session
        current_user: Current authenticated user
        
    Returns:
        Deactivation result
    """
    auth_service = AuthService(db)
    
    # Check if user exists and has permission to deactivate
    target_user = await auth_service.get_user_by_id(user_id)
    if not target_user:
        raise response_formatter.error(
            message="User not found",
            error_code="USER_NOT_FOUND",
            status_code=status.HTTP_404_NOT_FOUND
        )
    
    # Brand owners can only deactivate users from their own brand
    if (current_user.role == UserRole.BRAND_OWNER and 
        str(target_user.brand_id) != str(current_user.brand_id)):
        raise response_formatter.error(
            message="Cannot deactivate users from other brands",
            error_code="PERMISSION_DENIED",
            status_code=status.HTTP_403_FORBIDDEN
        )
    
    # Cannot deactivate self
    if str(target_user.id) == str(current_user.id):
        raise response_formatter.error(
            message="Cannot deactivate your own account",
            error_code="SELF_DEACTIVATION_NOT_ALLOWED",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    
    success, message = await auth_service.deactivate_user(user_id)
    
    if not success:
        raise response_formatter.error(
            message=message,
            error_code="USER_DEACTIVATION_FAILED",
            status_code=status.HTTP_400_BAD_REQUEST
        )
    
    logger.info(f"User deactivated by {current_user.email}: {target_user.email}")
    return response_formatter.success(message=message)